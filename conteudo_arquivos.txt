====== C:\Users\Administrator\Desktop\suporte-tecnico\.env ======
NODE_ENV = development
PORT = 5000
MONGO_URI = mongodb+srv://andersonpolv:kkFyJ2hJX5jaj803@suporte-tecnico.ydwhxh3.mongodb.net/supportdeskdb?retryWrites=true&w=majority
JWT_SECRET = abc123
====== C:\Users\Administrator\Desktop\suporte-tecnico\Listagem de conteúdos v2.bat ======
@echo off
chcp 65001 > nul
echo Listando arquivos...

REM Cria uma lista de arquivos ignorando node_modules, .git, etc.
dir /s /b /a-d > estrutura_arquivos.txt

REM Remove linhas com caminhos que contenham palavras ignoradas
findstr /v /i "node_modules .git package-lock.json public conteudo_arquivos.txt estrutura_arquivos.txt" estrutura_arquivos.txt > arquivos_filtrados.txt

echo Salvando conteúdo dos arquivos em conteudo_arquivos.txt...

(
    for /f "usebackq delims=" %%A in ("arquivos_filtrados.txt") do (
        echo ====== %%A ======
        type "%%A"
        echo.
    )
) > conteudo_arquivos.txt

echo Concluído! Verifique conteudo_arquivos.txt.
pause

====== C:\Users\Administrator\Desktop\suporte-tecnico\package.json ======
{
  "name": "support-desk",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node backend/server.js",
    "server": "nodemon backend/server.js",
    "client": "npm start --prefix frontend",
    "dev": "concurrently \"npm run server\" \"npm run client\"",
    "heroku-postbuild": "NPM_CONFIG_PRODUCTION=false npm install --prefix frontend && npm run build --prefix frontend"
  },
  "dependencies": {
    "ajv": "^6.12.6",
    "ajv-keywords": "^3.5.2",
    "bcryptjs": "^2.4.3",
    "colors": "^1.4.0",
    "concurrently": "^7.0.0",
    "dotenv": "^11.0.0",
    "express": "^4.17.2",
    "express-async-handler": "^1.2.0",
    "jsonwebtoken": "^8.5.1",
    "mongoose": "^6.1.6"
  },
  "devDependencies": {
    "nodemon": "^2.0.15"
  }
}

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\server.js ======
const express = require('express'); // sintaxe commonjs (module syntax). está trazendo o pacote express para cá (importação)
const dotenv = require('dotenv').config(); // método config; agora pode ir na pasta raiz e criar o arquivo ".env"
const { errorHandler } = require('./middleware/errorMiddleware');
const PORT = process.env.PORT || 5000; // camufla dados sensíveis graças ao "dotenv"; PORT é uma variável criada no arquivo ".env". aqui se pega o valor dessa variável PORT. tenta usar a porta do .env ou a 5000
const colors = require('colors'); // permite o uso do pacote colors em todo projeto
const connectDB = require('./config/db');
const path = require('path'); // faz parte de nodejs, dispensa instalações

connectDB();

const app = express();

app.use(express.json()); // cria um pedaço de middleware com ".use"; permite agora enviar raw json
app.use(express.urlencoded({ extended: false })); // middleware que permite enviar x-www-form-urlencoded

// cria uma rota com Express
// res.send('teste'); // poderia ser "res.json" no lugar de "res.send"
// res.json({
//     message: 'teste',
// });
// res.status(201).json({ // status 201 cria um novo arquivo
//     message: 'teste',
// });

// rotas
app.use('/api/users', require('./routes/userRoutes')); // usa o endpoint "/api/users" no arquivo "routes/userRoutes.js"
app.use('/api/tickets', require('./routes/ticketRoutes'));
app.use(errorHandler); // quando deixar um campo de cadastro vazio, ao invés de um arquivo html, agora envia de volta um json no postman. mais informações para debugar e não será mostrada em produção

if (process.env.NODE_ENV === 'production') {
    // atende/serve ao frontend
    app.use(express.static(path.join(__dirname, '../frontend/build'))); // define uma pasta/path estático. será a pasta frontend build (npm run build dentro de frontend) que será usada para deploy
    app.get('*', (req, res) =>
        res.sendFile(__dirname, '../', 'frontend', 'build', 'index.html')
    ); // cria rota. "*" significa tudo exceto as rotas criadas mais acima
} else {
    app.get('/', (req, res) => {
        res.status(200).json({
            message: 'Bem-vindo ao API de Suporte Técnico',
        });
    });
}

app.listen(PORT, () => console.log(`Servidor iniciou na porta ${PORT}`));

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\config\db.js ======
const mongoose = require('mongoose');
const connectDB = async () => {
    try {
        const conn = await mongoose.connect(process.env.MONGO_URI); // onde será feito a conexão; pega a uri de .env
        console.log(`MongoDB connectado ${conn.connection.host}`.cyan.underline); // ".cyan.underline" vem do pacote colors
    } catch (error) {
        console.log(`Erro ${error.message}`.red.underline.bold);
        process.exit(1); // fecha todo o processo caso haja falha
    }
};

module.exports = connectDB;

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\controllers\noteController.js ======
const asyncHandler = require('express-async-handler');
const User = require('../models/userModel');
const Ticket = require('../models/ticketModel');
const Note = require('../models/noteModel');

const getNotes = asyncHandler(async (req, res) => {
    // pega anotações a um ticket. GET request. endpoint: /api/tickets/:ticketId/notes. acesso privado
    const user = await User.findById(req.user.id);
    if (!user) {
        res.status(401);
        throw new Error('Essa anotação não existe');
    }
    const ticket = await Ticket.findById(req.params.ticketId); // pega id da url
    if (ticket.user.toString() !== req.user.id) {
        // certifica ser o ticket do usuário. "req.user.id" é o token
        res.status(401);
        throw new Error('Algo deu errado');
    }
    const notes = await Note.find({ tickets: req.params.ticketId });
    res.status(200).json(notes);
});

const addNote = asyncHandler(async (req, res) => { // POST request. acesso privado. endpoint: /api/tickets/:ticketId/notes
    const user = await User.findById(req.user.id);
    if (!user) {
        res.status(401);
        throw new Error('Essa anotação não existe');
    }
    const ticket = await Ticket.findById(req.params.ticketId);
    if (ticket.user.toString() !== req.user.id) {
        res.status(401);
        throw new Error('Algo deu errado');
    }
    const note = await Note.create({
        text: req.body.text,
        isStaff: false,
        ticket: req.params.ticketId,
        user: req.user.id
    });
    res.status(200).json(note);
});

module.exports = {
    getNotes,
    addNote
};

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\controllers\ticketController.js ======
const asyncHandler = require('express-async-handler');
const User = require('../models/userModel');
const Ticket = require('../models/ticketModel');

const getTickets = asyncHandler(async (req, res) => {
    // pega tickets do usuário. rota: /api/tickets; acesso privado; GET request
    const user = await User.findById(req.user.id); // pega usuário pelo jsonwebtoken, pois jwt inclui o user id. quando se valida o token, é feito um "req.user" pelo middleware
    if (!user) {
        res.status(401);
        throw new Error('Esse usuário não existe');
    }
    const tickets = await Ticket.find({ user: req.user.id }); // ocorre uso do "ticketModel"
    // res.status(200).json({
    //     message: 'getTickets',
    // });
    res.status(200).json(tickets);
});

const getTicket = asyncHandler(async (req, res) => {
    // pega um único ticket do usuário; endpoint: /api/tickets/:id; acesso privado. GET request
    const user = await User.findById(req.user.id);
    if (!user) {
        res.status(401);
        throw new Error('Esse usuário não existe');
    }
    const ticket = await Ticket.findById(req.params.id); // findById() vem do acesso à URL; "params" ajuda nesse sentido
    if (!ticket) {
        res.status(404);
        throw new Error('Esse ticket não existe');
    }
    if (ticket.user.toString() !== req.user.id) {
        // limita essa operação apenas ao usário (dono do ticket)
        res.status(401);
        throw new Error('Algo deu errado');
    }
    res.status(200).json(ticket);
});

const createTicket = asyncHandler(async (req, res) => {
    // cria um novo ticket. rota: /api/tickets; acesso privado; POST request
    const { product, description } = req.body;
    if (!product || !description) {
        // certifica de enviar product e
        // description
        res.status(400);
        throw new Error(
            'Por favor, adicione uma categoria e uma descrição do problema'
        );
    }
    const user = await User.findById(req.user.id);
    if (!user) {
        res.status(401);
        throw new Error('Esse usuário não existe');
    }
    const ticket = await Ticket.create({
        product,
        description,
        user: req.user.id,
        status: 'novo',
    });
    res.status(201).json(
        // ao invés de 200 será 201 (criado)
        ticket
    );
});

const deleteTicket = asyncHandler(async (req, res) => {
    // deleta ticket. DELETE request. endpoint: /api/tickets/:id; acesso privado
    const user = await User.findById(req.user.id);
    if (!user) {
        res.status(401);
        throw new Error('Esse usuário não existe');
    }
    const ticket = await Ticket.findById(req.params.id);
    if (!ticket) {
        res.status(404);
        throw new Error('Esse ticket não existe');
    }
    if (ticket.user.toString() !== req.user.id) {
        res.status(401);
        throw new Error('Algo deu errado');
    }
    await ticket.remove(); // não existe necessidade de return nem de criar uma variável
    res.status(200).json({ success: true });
});

const updateTicket = asyncHandler(async (req, res) => {
    // atualiza um ticket. PUT request. endpoint: /api/tickets/:id. acesso privado
    const user = await User.findById(req.user.id);
    if (!user) {
        res.status(401);
        throw new Error('Esse usuário não existe');
    }
    const ticket = await Ticket.findById(req.params.id);
    if (!ticket) {
        res.status(404);
        throw new Error('Esse ticket não existe');
    }
    if (ticket.user.toString() !== req.user.id) {
        res.status(401);
        throw new Error('Algo deu errado');
    }
    const updatedTicket = await Ticket.findByIdAndUpdate(
        req.params.id, // pega o id da url. product (categoria) e descrição estarão na body
        req.body,
        {
            new: true,
        }
    );
    res.status(200).json(updatedTicket);
});

module.exports = {
    getTickets,
    getTicket,
    createTicket,
    deleteTicket,
    updateTicket
};

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\controllers\userController.js ======
const asyncHandler = require('express-async-handler'); // middleware; será para o mongoose, que retorna promise; assim, aqui não será usado ".then" e sim async await
const bcrypt = require('bcryptjs'); // serve para fazer hash na senha
const User = require('../models/userModel');
const jwt = require('jsonwebtoken'); // jsonwebtoken (JWT) é a chave para acessar conteúdos futuros quando o usuário estiver autenticado; isso será guardado no frontend junto com react

const registerUser = asyncHandler(async (req, res) => {
    // rota: /api/users; acesso público
    // console.log(req.body); // req.body é onde vai estar todas informações, precisa criar o "body parser middleware" no "server.js"
    const { name, email, password } = req.body; // certifica das variáveis existirem através de desestruturação
    if (!name || !email || !password) {
        // validação
        // res.status(400).json({ message: 'Todos os campos são obrigatórios' }); // 200 ok, 400 client error (errou alguma informação). será criado um "error handler" adicionado como pedaço de middleware em server.js
        res.status(400);
        throw new Error('Todos os campos são obrigatórios'); // dessa vez, no postman, retorna o express error handler que é uma página html em tags body
    }
    const userExists = await User.findOne({ email }); // continuação caso esteja tudo preenchido. aqui, vai procurar se usuário já existe. método findOne() vem do model User: vai procurar um documento/item. email sozinho é o mesmo que email: email
    if (userExists) {
        res.status(400); // erro cliente
        throw new Error('Esse usuário já existe');
    }
    const salt = await bcrypt.genSalt(10); // faz hash na senha. 10 rounds são passados
    const hashedPassword = await bcrypt.hash(password, salt); // await porque as funções retornam promise
    const user = await User.create({
        // cria o usuário
        name,
        email,
        password: hashedPassword, // sem hashedPassword, a senha ficaria apenas em texto plano
    });
    if (user) {
        res.status(201).json({
            // OK. checagem do usuário criado, se OK, envia de volta
            _id: user._id, // "_" porque é a forma que mongodb lida com ids
            name: user.name,
            email: user.email,
            token: generateToken(user._id), // função separada que assina o token; ela precisa necessariamente do id passado
        });
    } else {
        res.status(400);
        throw new Error('Algo deu errado');
    }
    // res.send('Rota de cadastro'); // removido propositalmente
});

const loginUser = asyncHandler(async (req, res) => {
    // rota: /api/users/login; acesso público
    const { email, password } = req.body; // pega os dados da body enviados
    const user = await User.findOne({ email });
    if (user && (await bcrypt.compare(password, user.password))) {
        // se usuário é encontrado e a senha coincide... compara a senha em "texto plano" com a senha hash usando o método compare do pacote bcrypt
        res.status(200).json({
            // não será 201 porque não está criando nada
            _id: user._id,
            name: user.name,
            email: user.email,
            token: generateToken(user._id), // precisa também estar no login
        });
    } else {
        res.status(401); // erro, não autorizado
        throw new Error('Algo deu errado');
    }
    // res.send('Rota de login');
});

const getMe = asyncHandler(async (req, res) => {
    // pega usuário logado. rota: /api/users/me; acesso privado
    // res.send('me');
    const user = {
        id: req.user._id,
        email: req.user.email,
        name: req.user.name
    }
    // res.status(200).json(req.user); // authMiddleware permite agora o acesso ao "req.user"
    res.status(200).json(user); // versão desestruturada que pega campos específicos
});

const generateToken = (id) => {
    return jwt.sign({ id }, process.env.JWT_SECRET, {
        // jwt requer um "secret" guarda no .env e passado como argumento pelo método sign()
        expiresIn: '30d', // token expira em 30 dias. agora ao registrar ou logar gera um token de volta
    });
};

module.exports = {
    registerUser,
    loginUser,
    getMe
};

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\middleware\authMiddleware.js ======
// aqui será onde protege rotas específicas (envio de tickets)

const jwt = require('jsonwebtoken');
const asyncHandler = require('express-async-handler');
const User = require('../models/userModel');

const protect = asyncHandler(async (req, res, next) => {
    // função protetora de rotas
    let token;
    if (
        req.headers.authorization &&
        req.headers.authorization.startsWith('Bearer')
    ) {
        // checa token no header; esse token será guardado no frontend react. a maneira que será enviada é "Bearer Token"
        try {
            token = req.headers.authorization.split(' ')[1]; // pega token do header; split(' ') criará o espaço necessário para a formatação como "Bearer Token", criado como array e no índice 1 que pega o item "Token"
            const decoded = jwt.verify(token, process.env.JWT_SECRET); // verifica token
            req.user = await User.findById(decoded.id).select('-password'); // pega usuário do token. ".select('-password')" exclui a senha do dado retornado do usuário
            next(); // chama o próximo pedaço de middleware
        } catch (error) {
            console.log(error);
            res.status(401);
            throw new Error('Algo deu errado');
        }
    }
    if (!token) {
        res.status(401);
        throw new Error('Algo deu errado');
    }
});

module.exports = { protect }

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\middleware\errorMiddleware.js ======
const errorHandler = (err, req, res, next) => {
    // err de error
    const statusCode = res.statusCode ? res.statusCode : 500; // objeto res tem status code que será o que for definido em "res.status()" no arquivo "userController.js"; 500 server error. caso o usuário não estiver lá, retorna o erro 500
    res.status(statusCode);
    res.json({
        message: err.message,
        stack: process.env.NODE_ENV === 'production' ? null : err.stack, // envia stack trace. só será enviada se fora de produção
    });
};

module.exports = { errorHandler }
====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\models\noteModel.js ======
const mongoose = require('mongoose');

const noteSchema = mongoose.Schema(
    {
        user: {
            type: mongoose.Schema.Types.ObjectId,
            required: [true],
            ref: 'User',
        },
        ticket: {
            type: mongoose.Schema.Types.ObjectId,
            required: [true],
            ref: 'Ticket',
        },
        text: {
            type: String,
            required: [true, 'Por favor, adicione um algum texto'],
        },
        isStaff: {
            type: Boolean,
            default: false
        },
        staffId: {
            type: String,
        },
    },
    {
        timestamps: true,
    }
);

module.exports = mongoose.model('Note', noteSchema);

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\models\ticketModel.js ======
const mongoose = require('mongoose');

const ticketSchema = mongoose.Schema(
    // cada ticket estará conectado a um usuário
    {
        user: {
            type: mongoose.Schema.Types.ObjectId, // relaciona esse campo ao object id
            required: [true],
            ref: 'User', // relaciona ao collection User
        },
        product: {
            type: String,
            required: [true, 'Por favor, selecione uma categoria'],
            enum: [ // "produtos" específicos que poderão ser enviados
                'Suporte geral do Windows 10 ou 11',
                'Montagem e upgrade de desktop',
                'Análise de telas azuis',
            ],
        },
        description: {
            type: String,
            required: [true, 'Por favor, adicione uma descrição do problema'],
        },
        status: {
            type: String,
            enum: ['novo', 'aberto', 'fechado'],
            default: 'novo',
        },
    },
    {
        timestamps: true,
    }
);

module.exports = mongoose.model('Ticket', ticketSchema);

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\models\userModel.js ======
// models são schemas compostos pelos campos que estarão presentes na página de usuário

const mongoose = require('mongoose');
const userSchema = mongoose.Schema(
    {
        name: {
            type: String,
            required: [true, 'Por favor, adicione um nome'], // poderia ser só true
        },
        email: {
            type: String,
            required: [true, 'Por favor, adicione um e-mail'],
            unique: true,
        },
        password: {
            type: String,
            required: [true, 'Por favor, adicione uma senha'],
        },
        isAdmin: {
            // não será usado no frontend (ui), mas em caso dos usuários quererem ser admin para fazer certas coisas...
            type: Boolean,
            required: true,
            default: false,
        },
    },
    {
        timestamps: true, // não está em seu próprio campo; após o objeto schema vem timestamps; adiciona marcações de tempo automáticas
    }
);

module.exports = mongoose.model('User', userSchema);

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\routes\noteRoutes.js ======
const express = require('express');
const router = express.Router({ mergeParams: true });
const { getNotes, addNote } = require('../controllers/noteController');
const { protect } = require('../middleware/authMiddleware');

router.route('/').get(protect, getNotes).post(protect, addNote);

module.exports = router;

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\routes\ticketRoutes.js ======
const express = require('express');
const router = express.Router();
const { protect } = require('../middleware/authMiddleware');
const {
    getTickets,
    getTicket,
    createTicket,
    updateTicket,
    deleteTicket,
} = require('../controllers/ticketController');
const noteRouter = require('./noteRoutes');

router.use('/:ticketId/notes', noteRouter); // "/:ticketId/notes" agora pertence ao "noteRouter". refaz a rota para noteRouter

router.route('/').get(protect, getTickets).post(protect, createTicket); // requests encadeados por conta de "router.route". tudo em uma linha só. rota "get" será protegida, ou seja, pegar tickets de usuários precisa estar autenticado. "get" estará conectado à função "getTickets" em ticketController. o mesmo ocorre para "post"

router
    .route('/:id')
    .get(protect, getTicket)
    .delete(protect, deleteTicket)
    .put(protect, updateTicket);

module.exports = router;

====== C:\Users\Administrator\Desktop\suporte-tecnico\backend\routes\userRoutes.js ======
const express = require('express');
const router = express.Router(); // importa o roteamento de express
const {
    registerUser,
    loginUser,
    getMe,
} = require('../controllers/userController'); // poderia ter a lógica de ter todas funções junto às rota, mas foram substituídas por uma controller function (mais limpo)

const { protect } = require('../middleware/authMiddleware'); // uso desse midleware ocorre com "protect" como argumento adicional

// router.post('/', (req, res) => {
//     // post request. req e res são convenções para request e response
//     res.send('Rota de cadastro');
// });

// router.post('/login', (req, res) => {
//     res.send('Rota de login');
// });

router.post('/', registerUser); // http://localhost:5000/api/users/
router.post('/login', loginUser); // http://localhost:5000/api/users/login
router.get('/me', protect, getMe); // http://localhost:5000/api/users/me será uma rota protegida a qual o envio de uma request com json web token retornará informações do atual usuário logado

module.exports = router;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\package.json ======
{
  "name": "suporte-tecnico",
  "version": "0.1.0",
  "proxy": "http://localhost:5000",
  "private": true,
  "dependencies": {
    "@reduxjs/toolkit": "^1.7.1",
    "@testing-library/jest-dom": "^4.2.4",
    "@testing-library/react": "^9.5.0",
    "@testing-library/user-event": "^7.2.1",
    "axios": "^0.24.0",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-icons": "^4.3.1",
    "react-modal": "^3.14.4",
    "react-redux": "^7.2.6",
    "react-router-dom": "^6.2.1",
    "react-scripts": "5.0.0",
    "react-toastify": "^8.1.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\App.js ======
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Home from './pages/Home';
import Login from './pages/Login';
import Register from './pages/Register';
import Header from './components/Header';
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import NewTicket from './pages/NewTicket';
import PrivateRoute from './components/PrivateRoute';
import Tickets from './pages/Tickets';
import Ticket from './pages/Ticket';

function App() {
  return (
    <>
      <Router>
        <div className="container">
          <Header />
          {/* tem que estar acima da tag Routes porque Header não é um componente "Route" */}
          <Routes>
            <Route path="/" element={<Home />} />
            <Route path="/login" element={<Login />} />
            <Route path="/register" element={<Register />} />
            {/* <Route path='/new-ticket' element={<NewTicket />} /> */}
            <Route path="/new-ticket" element={<PrivateRoute />}> {/* nested route. "NewTicket" ficou uma rota privada, envoltada pela "PrivateRoute" e com a mesma URL para ambos */}
              <Route path="/new-ticket" element={<NewTicket />} />
            </Route>
            <Route path="/tickets" element={<PrivateRoute />}>
              <Route path="/tickets" element={<Tickets />} />
            </Route>
            <Route path="/ticket/:ticketId" element={<PrivateRoute />}>
              <Route path="/ticket/:ticketId" element={<Ticket />} />
            </Route>
          </Routes>
        </div>
      </Router>
      <ToastContainer />
      {/* permite uso do toast em qualquer canto do projeto */}
    </>
  );
}

export default App;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\index.css ======
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap');

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Poppins', sans-serif;
  height: 100vh;
}

a {
  text-decoration: none;
  color: #000;
}

p {
  line-height: 1.7;
}

ul {
  list-style: none;
}

li {
  line-height: 2.2;
}

h1,
h2,
h3 {
  font-weight: 600;
  margin-bottom: 10px;
}

.container {
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  text-align: center;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 0;
  border-bottom: 1px solid #e6e6e6;
  margin-bottom: 60px;
}

.header ul {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.header ul li {
  margin-left: 20px;
}

.header ul li a {
  display: flex;
  align-items: center;
}

.header ul li a:hover {
  color: #777;
}

.header ul li a svg {
  margin-right: 5px;
}

.heading {
  font-size: 2rem;
  font-weight: 700;
  margin-bottom: 50px;
  padding: 0 20px;
}

.heading p {
  color: #828282;
}

.boxes {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  justify-content: space-between;
  align-items: center;
  text-align: center;
  margin-bottom: 30px;
}

.boxes div {
  padding: 30px;
  border: 1px solid #e6e6e6;
  border-radius: 10px;
}

.boxes h2 {
  margin-top: 20px;
}

.boxes a:hover {
  color: #777;
}

.form {
  width: 70%;
  margin: 0 auto;
}

.form-group {
  margin-bottom: 10px;
}

.form-group input,
.form-group textarea,
.form-group select {
  width: 100%;
  padding: 10px;
  border: 1px solid #e6e6e6;
  border-radius: 5px;
  margin-bottom: 10px;
  font-family: inherit;
}

.form-group label {
  text-align: left;
  display: block;
  margin: 0 0 5px 3px;
}

.btn {
  padding: 10px 20px;
  border: 1px solid #000;
  border-radius: 5px;
  background: #000;
  color: #fff;
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  text-align: center;
  appearance: button;
  display: flex;
  align-items: center;
  justify-content: center;
}

.btn svg {
  margin-right: 8px;
}

.btn-reverse {
  background: #fff;
  color: #000;
}

.btn-block {
  width: 100%;
  margin-bottom: 20px;
}

.btn-sm {
  padding: 5px 15px;
  font-size: 13px;
}

.btn-danger {
  background: darkred;
  border: none;
}

.btn-back {
  width: 150px;
  margin-bottom: 20px;
}

.btn:hover {
  transform: scale(0.98);
}

.ticket-created {
  border: 1px solid #e6e6e6;
  border-radius: 5px;
  padding: 50px;
}

.ticket-number {
  margin-bottom: 30px;
}

.ticket-number h2 {
  font-size: 2.3rem;
  margin-bottom: 10px;
}

.ticket-number p {
  font-size: 1.3rem;
}

.ticket-info {
  font-size: 1.3rem;
}

.ticket,
.ticket-headings {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 20px;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  background: #f4f4f4;
  padding: 10px 15px;
  border-radius: 5px;
  text-align: center;
}

.ticket-headings {
  font-weight: 700;
}

.status {
  background-color: #333;
  color: #fff;
  width: 100px;
  padding: 0 20px;
  justify-self: center;
  border-radius: 10px;
  font-size: 16px;
  text-align: center;
}

.status-novo {
  background-color: green;
  color: #fff;
  border-radius: 10px;
}

.status-aberto {
  background-color: steelblue;
  color: #fff;
  border-radius: 10px;
}

.status-fechado {
  background-color: darkred;
  color: #fff;
  border-radius: 10px;
}

.ticket-page {
  position: relative;
  text-align: left;
  padding-bottom: 20px;
}

.ticket-page h2 {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.ticket-page .btn {
  margin-bottom: 30px;
}

.ticket-page .btn-block {
  width: 100%;
  margin-top: 30px;
}

.ticket-desc {
  margin: 20px 0;
  font-size: 17px;
  background-color: #f4f4f4;
  border: 1px #ccc solid;
  padding: 10px 15px;
  border-radius: 5px;
}

.ticket-desc:focus {
  outline: none;
}

.note {
  border: 1px solid #e6e6e6;
  border-radius: 5px;
  text-align: left;
  padding: 20px;
  margin-bottom: 20px;
  position: relative;
}

.note-head {
  background: #f4f4f4;
  padding: 5px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

/* Remove o contorno azul ao focar */
.note-textarea:focus {
  outline: none;
}

.note-date {
  position: absolute;
  top: 15px;
  right: 10px;
  font-size: 14px;
}

.delete-note {
  color: red;
  cursor: pointer;
  position: absolute;
  bottom: 10px;
  right: 20px;
}

.btn-close {
  background: none;
  border: none;
  color: #000;
  position: absolute;
  top: 5px;
  right: 5px;
  font-size: 16px;
  cursor: pointer;
}

.btn-close:hover {
  color: red;
  transform: scale(0.98);
}

p.status-in-progress {
  color: orangered;
}

p.status-waiting {
  color: red;
}

p.status-ready {
  color: steelblue;
}

p.status-complete {
  color: green;
}

footer {
  position: sticky;
  top: 95vh;
  text-align: center;
}

.loadingSpinnerContainer {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 5000;
  display: flex;
  justify-content: center;
  align-items: center;
}

.loadingSpinner {
  width: 64px;
  height: 64px;
  border: 8px solid;
  border-color: #000 transparent #555 transparent;
  border-radius: 50%;
  animation: spin 1.2s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

@media (max-width: 600px) {
  .boxes {
    grid-template-columns: 1fr;
  }

  .form {
    width: 90%;
  }

  .ticket-created h2,
  .heading h1 {
    font-size: 2rem;
  }

  .heading p {
    font-size: 1.5rem;
  }
}

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\index.js ======
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import { store } from './app/store';
import { Provider } from 'react-redux';
import * as serviceWorker from './serviceWorker';

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://bit.ly/CRA-PWA
serviceWorker.unregister();

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\serviceWorker.js ======
// This optional code is used to register a service worker.
// register() is not called by default.

// This lets the app load faster on subsequent visits in production, and gives
// it offline capabilities. However, it also means that developers (and users)
// will only see deployed updates on subsequent visits to a page, after all the
// existing tabs open on the page have been closed, since previously cached
// resources are updated in the background.

// To learn more about the benefits of this model and instructions on how to
// opt-in, read https://bit.ly/CRA-PWA

const isLocalhost = Boolean(
  window.location.hostname === 'localhost' ||
    // [::1] is the IPv6 localhost address.
    window.location.hostname === '[::1]' ||
    // 127.0.0.0/8 are considered localhost for IPv4.
    window.location.hostname.match(
      /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/
    )
);

export function register(config) {
  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
    // The URL constructor is available in all browsers that support SW.
    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);
    if (publicUrl.origin !== window.location.origin) {
      // Our service worker won't work if PUBLIC_URL is on a different origin
      // from what our page is served on. This might happen if a CDN is used to
      // serve assets; see https://github.com/facebook/create-react-app/issues/2374
      return;
    }

    window.addEventListener('load', () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

      if (isLocalhost) {
        // This is running on localhost. Let's check if a service worker still exists or not.
        checkValidServiceWorker(swUrl, config);

        // Add some additional logging to localhost, pointing developers to the
        // service worker/PWA documentation.
        navigator.serviceWorker.ready.then(() => {
          console.log(
            'This web app is being served cache-first by a service ' +
              'worker. To learn more, visit https://bit.ly/CRA-PWA'
          );
        });
      } else {
        // Is not localhost. Just register service worker
        registerValidSW(swUrl, config);
      }
    });
  }
}

function registerValidSW(swUrl, config) {
  navigator.serviceWorker
    .register(swUrl)
    .then((registration) => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing;
        if (installingWorker == null) {
          return;
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === 'installed') {
            if (navigator.serviceWorker.controller) {
              // At this point, the updated precached content has been fetched,
              // but the previous service worker will still serve the older
              // content until all client tabs are closed.
              console.log(
                'New content is available and will be used when all ' +
                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'
              );

              // Execute callback
              if (config && config.onUpdate) {
                config.onUpdate(registration);
              }
            } else {
              // At this point, everything has been precached.
              // It's the perfect time to display a
              // "Content is cached for offline use." message.
              console.log('Content is cached for offline use.');

              // Execute callback
              if (config && config.onSuccess) {
                config.onSuccess(registration);
              }
            }
          }
        };
      };
    })
    .catch((error) => {
      console.error('Error during service worker registration:', error);
    });
}

function checkValidServiceWorker(swUrl, config) {
  // Check if the service worker can be found. If it can't reload the page.
  fetch(swUrl, {
    headers: { 'Service-Worker': 'script' },
  })
    .then((response) => {
      // Ensure service worker exists, and that we really are getting a JS file.
      const contentType = response.headers.get('content-type');
      if (
        response.status === 404 ||
        (contentType != null && contentType.indexOf('javascript') === -1)
      ) {
        // No service worker found. Probably a different app. Reload the page.
        navigator.serviceWorker.ready.then((registration) => {
          registration.unregister().then(() => {
            window.location.reload();
          });
        });
      } else {
        // Service worker found. Proceed as normal.
        registerValidSW(swUrl, config);
      }
    })
    .catch(() => {
      console.log(
        'No internet connection found. App is running in offline mode.'
      );
    });
}

export function unregister() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready.then((registration) => {
      registration.unregister();
    });
  }
}

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\app\store.js ======
// aqui é onde se coloca reducers criados

import { configureStore } from '@reduxjs/toolkit';
import authReducer from '../features/auth/authSlice';
import ticketReducer from '../features/tickets/ticketSlice';
import noteReducer from '../features/notes/noteSlice';

export const store = configureStore({
  reducer: {
    auth: authReducer,
    tickets: ticketReducer,
    notes: noteReducer,
  },
});

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\components\BackButton.jsx ======
import { FaArrowCircleLeft } from 'react-icons/fa';
import { Link } from 'react-router-dom';

const BackButton = ({ url }) => {
  return (
    <Link className="btn btn-reverse btn-back" to={url}>
      <FaArrowCircleLeft />
      Voltar
    </Link>
  );
};

export default BackButton;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\components\Header.jsx ======
import { FaSignInAlt, FaSignOutAlt, FaUser } from 'react-icons/fa';
import { Link, useNavigate } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import { logout, reset } from '../features/auth/authSlice';

function Header() {
  const navigate = useNavigate();
  const dispatch = useDispatch();
  const { user } = useSelector((state) => state.auth);
  const onLogout = () => {
    dispatch(logout());
    dispatch(reset());
    navigate('/'); // está saindo pelo localstorage, mas precisa sair também do state. isso será feito em authSlice com um case próprio
  };
  return (
    <header className="header">
      <div className="logo">
        <Link to="/">Suporte Técnico</Link>
      </div>
      {/* o que é visto na navbar é diferente se o usuário está logado ou não */}
      <ul>
        {user ? (
          <li>
            <button className="btn" onClick={onLogout}>
              <FaSignOutAlt /> Sair
            </button>
          </li>
        ) : (
          <>
            {/* não pode ter dois elementos envoltados em um, por isso precisa de
            fragment. aqui será o else, ou seja, quando não tiver um usuário logado */}
            <li>
              <Link to="/login">
                <FaSignInAlt /> Entrar
              </Link>
            </li>
            <li>
              <Link to="/register">
                <FaUser /> Cadastrar
              </Link>
            </li>
          </>
        )}
      </ul>
    </header>
  );
}

export default Header;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\components\NoteItem.js ======
import { useSelector } from 'react-redux';
import { useEffect, useRef } from 'react';

function NoteItem({ note }) {
  const { user } = useSelector((state) => state.auth);
  const textareaRef = useRef(null);
  // Ajusta a altura da textarea automaticamente
  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = 'auto'; // Reseta a altura para recalcular
      textarea.style.height = `${textarea.scrollHeight}px`; // Define a altura com base no conteúdo
    }
  }, [note.text]); // Executa sempre que note.text mudar
  return (
    <div
      className="note"
      style={{
        backgroundColor: note.isStaff ? 'rgba(0,0,0,0.7' : '#fff',
        color: note.isStaff ? '#fff' : '#000',
      }}
    >
      <h4>
        Observações de{' '}
        {note.isStaff ? <span>suporte</span> : <span>{user.name}</span>}
        <textarea
          ref={textareaRef} // Agora textareaRef está definido
          className="note-textarea"
          value={note.text || ''}  // Garante que não haja erro se note.text for undefined
          readOnly
          style={{
            resize: 'none',
            width: '100%',
            minHeight: '50px',
            height: 'auto',
            border: 'none',
            backgroundColor: 'transparent',
            fontFamily: 'inherit',
            fontSize: 'inherit',
            padding: '0',
            color: 'inherit',
          }}
        />
        <div className="note-date">
          {new Date(note.createdAt).toLocaleString('pt-br')}
        </div>
      </h4>
    </div>
  );
}

export default NoteItem;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\components\PrivateRoute.jsx ======
import { Navigate, Outlet } from 'react-router-dom';
import { useAuthStatus } from '../hooks/useAuthStatus';
import Spinner from './Spinner';

const PrivateRoute = () => {
  const { loggedIn, checkingStatus } = useAuthStatus();
  if (checkingStatus) return <Spinner />;
  return loggedIn ? <Outlet /> : <Navigate to="/login" />;
};

export default PrivateRoute;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\components\Spinner.jsx ======
function Spinner() {
  return (
    <div className="loadingSpinnerContainer">
      <div className="loadingSpinner"></div>
    </div>
  );
}

export default Spinner;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\components\TicketItem.jsx ======
import { Link } from 'react-router-dom';

function TicketItem({ ticket }) {
  return (
    <div className="ticket">
      <div>{new Date(ticket.createdAt).toLocaleString('pt-br')}</div>
      <div>{ticket.product}</div>
      <div className={`status status-${ticket.status}`}>{ticket.status}</div>
      <Link to={`/ticket/${ticket._id}`} className="btn btn-reverse btn-sm">
        Visualizar
      </Link>
    </div>
  );
}

export default TicketItem;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\features\auth\authService.js ======
import axios from 'axios'; // poderia ser fetch api no lugar do axios

const API_URL = '/api/users/'; // "/api/users" é o endpoint de autenticação
const register = async (userData) => {
    // registra usuário
    const response = await axios.post(API_URL, userData); // está fazendo as mesmas interações que ocorreram em postman, mas dentro do app. "userData" é o nome, email e senha
    if (response.data) {
        localStorage.setItem('user', JSON.stringify(response.data)); // salva as informações do usuário incluindo o web token json como string
    }
    return response.data;
};

const login = async (userData) => {
    const response = await axios.post(API_URL + 'login', userData); // a concatenação faz acontecer: "api/users/login"
    if (response.data) {
        localStorage.setItem('user', JSON.stringify(response.data));
    }
    return response.data;
};


const logout = () => {
    // realiza logout de um usuário
    localStorage.removeItem('user');
};

const authService = {
    register,
    logout,
    login
};

export default authService;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\features\auth\authSlice.js ======
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import authService from './authService';

// dar F5 faz o user ficar null; precisa não só salvar a user ao localstorage, mas fazer o user em um state inicial caso ele exista
const user = JSON.parse(localStorage.getItem('user')); // aqui irá pegar o usuário do localstorage

const initialState = {
    user: user ? user : null, // se existe o user, use o user; caso contrário, use o null
    isError: false,
    isSuccess: false,
    isLoading: false,
    message: '',
};

export const register = createAsyncThunk(
    'auth/register',
    async (user, thunkAPI) => {
        // "createAsyncThunk" é uma função que permite usar dados assíncronos. "user" vem do formulário Register.jsx. aqui se registra um novo usuário
        // console.log(user);
        try {
            return await authService.register(user);
        } catch (error) {
            const message = // pega mensagem do backend
                (error.response &&
                    error.response.data &&
                    error.response.data.message) ||
                error.message ||
                error.toString();
            return thunkAPI.rejectWithValue(message); // coloca as possíveis mensagens de erro em um payload
        }
    }
);

export const login = createAsyncThunk('auth/login', async (user, thunkAPI) => {
    // aqui loga um usuário
    // console.log(user);
    try {
        return await authService.login(user);
    } catch (error) {
        const message =
            (error.response &&
                error.response.data &&
                error.response.data.message) ||
            error.message ||
            error.toString();
        return thunkAPI.rejectWithValue(message);
    }
});

export const logout = createAsyncThunk('auth/logout', async () => {
    await authService.logout(); // será chamado pelo header
});

export const authSlice = createSlice({
    name: 'auth',
    initialState,
    reducers: {
        reset: (state) => {
            // reducer que volta ao valor default dos states. será chamado no componente Register
            state.isLoading = false;
            state.isError = false;
            state.isSuccess = false;
            state.message = '';
        },
    },
    extraReducers: (builder) => {
        // "builder" permite adicionar "cases"
        builder
            .addCase(register.pending, (state) => {
                // chain de "addCase"
                state.isLoading = true;
            })
            .addCase(register.fulfilled, (state, action) => {
                state.isLoading = false; // o pedido foi realizado
                state.isSuccess = true;
                state.user = action.payload; // similar ao context api
            })
            .addCase(register.rejected, (state, action) => {
                // caso algo dê errado
                state.isLoading = false;
                state.isError = true;
                state.message = action.payload; // se sabe que o payload vai ter essa mensagem porque está no state rejected. será chamada mais em cima do código "return thunkAPI.rejectWithValue(message)". bom porque não precisa lidar com tudo manualmente por conta do redux toolkit
                state.user = null;
            })
            .addCase(login.pending, (state) => {
                state.isLoading = true;
            })
            .addCase(login.fulfilled, (state, action) => {
                state.isLoading = false;
                state.isSuccess = true;
                state.user = action.payload;
            })
            .addCase(login.rejected, (state, action) => {
                state.isLoading = false;
                state.isError = true;
                state.message = action.payload;
                state.user = null;
            })
            .addCase(logout.fulfilled, (state) => {
                state.user = null;
            })
    },
});

export const { reset } = authSlice.actions;
export default authSlice.reducer;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\features\notes\noteService.js ======
import axios from 'axios';

const API_URL = '/api/tickets/';

const getNotes = async (ticketId, token) => {
    // pega anotações de um ticket
    const config = {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    };
    const response = await axios.get(API_URL + ticketId + '/notes', config); // a concatenação certifica de atingir o endpoint desejado
    return response.data;
};

const createNote = async (noteText, ticketId, token) => {
    const config = {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    };
    const response = await axios.post(
        API_URL + ticketId + '/notes',
        {
            text: noteText,
        },
        config
    );
    return response.data;
};

const noteService = {
    getNotes,
    createNote,
};

export default noteService;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\features\notes\noteSlice.js ======
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import noteService from './noteService';

const initialState = {
    notes: [],
    isError: false,
    isSuccess: false,
    isLoading: false,
    message: '',
};

export const getNotes = createAsyncThunk(
    // pega anotações de um ticket
    'notes/getAll',
    async (ticketId, thunkAPI) => {
        try {
            const token = thunkAPI.getState().auth.user.token;
            return await noteService.getNotes(ticketId, token);
        } catch (error) {
            const message =
                (error.response &&
                    error.response.data &&
                    error.response.data.message) ||
                error.message ||
                error.toString();
            return thunkAPI.rejectWithValue(message);
        }
    }
);

export const createNote = createAsyncThunk(
    'notes/create',
    async ({ noteText, ticketId }, thunkAPI) => {
        try {
            const token = thunkAPI.getState().auth.user.token;
            return await noteService.createNote(noteText, ticketId, token);
        } catch (error) {
            const message =
                (error.response &&
                    error.response.data &&
                    error.response.data.message) ||
                error.message ||
                error.toString();
            return thunkAPI.rejectWithValue(message);
        }
    }
);

export const noteSlice = createSlice({
    name: 'note',
    initialState,
    reducers: {
        reset: (state) => initialState,
    },
    extraReducers: (builder) => {
        builder
            .addCase(getNotes.pending, (state) => {
                state.isLoading = true;
            })
            .addCase(getNotes.fulfilled, (state, action) => {
                state.isLoading = false;
                state.isSuccess = true;
                state.notes = action.payload;
            })
            .addCase(getNotes.rejected, (state, action) => {
                state.isLoading = false;
                state.isError = true;
                state.message = action.payload;
            })
            .addCase(createNote.pending, (state) => {
                state.isLoading = true;
            })
            .addCase(createNote.fulfilled, (state, action) => {
                state.isLoading = false;
                state.isSuccess = true;
                state.notes.push(action.payload); // exibirá diretamente na UI sem precisar dar F5. isso só é possível graças ao redux toolkit
            })
            .addCase(createNote.rejected, (state, action) => {
                state.isLoading = false;
                state.isError = true;
                state.message = action.payload;
            });
    },
});

export const { reset } = noteSlice.actions;
export default noteSlice.reducer;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\features\tickets\ticketService.js ======
// aqui ocorre os requests

import axios from 'axios';

const API_URL = '/api/tickets/';

const createTicket = async (ticketData, token) => {
    // cria um ticket novo
    const config = {
        // envio de token precisa estar no headers e no campo de autorização (como ocorre no postman)
        headers: {
            Authorization: `Bearer ${token}`,
        },
    };
    const response = await axios.post(API_URL, ticketData, config);
    return response.data;
};

const getTickets = async (token) => {
    // pega tickets do usuário
    const config = {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    };
    const response = await axios.get(API_URL, config);
    return response.data;
};

const getTicket = async (ticketId, token) => {
    const config = {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    };
    const response = await axios.get(API_URL + ticketId, config);
    return response.data;
};

const closeTicket = async (ticketId, token) => {
    const config = {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    };
    const response = await axios.put(API_URL + ticketId, { status: 'fechado' }, config);
    return response.data;
};

const ticketService = {
    createTicket,
    getTickets,
    getTicket,
    closeTicket
};

export default ticketService;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\features\tickets\ticketSlice.js ======
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import ticketService from './ticketService';

const initialState = {
    tickets: [], // array para múltiplos tickets
    ticket: {}, // objeto para um único ticket
    isError: false, // contando com esa, são 4 propriedades correspondentes aos 4 recursos de redux
    isSuccess: false,
    isLoading: false,
    message: '',
};

export const createTicket = createAsyncThunk(
    // cria um ticket novo
    'tickets/create',
    async (ticketData, thunkAPI) => {
        try {
            const token = thunkAPI.getState().auth.user.token; // objeto "thunkAPI" tem um método chamado getState que pega state de outras partes do projeto. aqui pega o token
            return await ticketService.createTicket(ticketData, token); // envia o token ao ticketService junto com a informação do ticket
        } catch (error) {
            const message =
                (error.response &&
                    error.response.data &&
                    error.response.data.message) ||
                error.message ||
                error.toString();
            return thunkAPI.rejectWithValue(message);
        }
        // precisa enviar o token e acessar a rota protegida para enviar a informação
    }
);

export const getTickets = createAsyncThunk(
    // pega os tickets do usuário
    'tickets/getAll',
    async (_, thunkAPI) => {
        // "ticketData" foi substituído pelo placeholder "_", ou seja, significa que não passará nada mas continua acessando o thunkAPI (p/ pegar o token)
        try {
            const token = thunkAPI.getState().auth.user.token;
            return await ticketService.getTickets(token);
        } catch (error) {
            const message =
                (error.response &&
                    error.response.data &&
                    error.response.data.message) ||
                error.message ||
                error.toString();
            return thunkAPI.rejectWithValue(message);
        }
    }
);

export const getTicket = createAsyncThunk(
    'tickets/get',
    async (ticketId, thunkAPI) => {
        try {
            const token = thunkAPI.getState().auth.user.token;
            return await ticketService.getTicket(ticketId, token);
        } catch (error) {
            const message =
                (error.response &&
                    error.response.data &&
                    error.response.data.message) ||
                error.message ||
                error.toString();
            return thunkAPI.rejectWithValue(message);
        }
    }
);

export const closeTicket = createAsyncThunk(
    'tickets/close',
    async (ticketId, thunkAPI) => {
        try {
            const token = thunkAPI.getState().auth.user.token;
            return await ticketService.closeTicket(ticketId, token);
        } catch (error) {
            const message =
                (error.response &&
                    error.response.data &&
                    error.response.data.message) ||
                error.message ||
                error.toString();
            return thunkAPI.rejectWithValue(message);
        }
    }
);

export const ticketSlice = createSlice({
    name: 'ticket',
    initialState,
    reducers: {
        reset: (state) => initialState, // pega o state e retorna aos valores padrões
    },
    extraReducers: (builder) => {
        builder
            .addCase(createTicket.pending, (state) => {
                state.isLoading = true;
            })
            .addCase(createTicket.fulfilled, (state) => {
                state.isLoading = false;
                state.isSuccess = true;
            })
            .addCase(createTicket.rejected, (state, action) => {
                state.isLoading = false;
                state.isError = true;
                state.message = action.payload;
            })
            .addCase(getTickets.pending, (state) => {
                state.isLoading = true;
            })
            .addCase(getTickets.fulfilled, (state, action) => {
                // será passado "action" porque "getTickets" pega informações
                state.isLoading = false;
                state.isSuccess = true;
                state.tickets = action.payload; // ticket = pedaço de state para um único objeto
            })
            .addCase(getTickets.rejected, (state, action) => {
                state.isLoading = false;
                state.isError = true;
                state.message = action.payload;
            })
            .addCase(getTicket.pending, (state) => {
                state.isLoading = true;
            })
            .addCase(getTicket.fulfilled, (state, action) => {
                state.isLoading = false;
                state.isSuccess = true;
                state.ticket = action.payload;
            })
            .addCase(getTicket.rejected, (state, action) => {
                state.isLoading = false;
                state.isError = true;
                state.message = action.payload;
            })
            .addCase(closeTicket.fulfilled, (state, action) => {
                state.isLoading = false;
                state.tickets.map((ticket) =>
                    ticket._id === action.payload._id
                        ? (ticket.status = 'fechado')
                        : ticket
                ); // "tickets" é o array que será iterado por map e por lá definido o ticket correto através do id vindo do payload (action). dessa forma se consegue por o status como "fechado". aqui só faz efeito na UI; reflete na tela sem precisar recarregar a página
            });
    },
});

export const { reset } = ticketSlice.actions; // aqui exporta para "src/app/store.js"
export default ticketSlice.reducer;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\hooks\useAuthStatus.js ======
// evita de usuário não logado visualizar à página de criar ticket. redireciona o usuário não logado à página inicial

import { useState, useEffect } from 'react';
import { useSelector } from 'react-redux';

export const useAuthStatus = () => {
    const [loggedIn, setLoggedIn] = useState(false);
    const [checkingStatus, setCheckingStatus] = useState(true);
    const { user } = useSelector((state) => state.auth); // selecionará o usuário do "state auth" pelo redux e ver se está logado ou não
    useEffect(() => {
        if (user) {
            // checa se o usuário está logado
            setLoggedIn(true);
        } else {
            setLoggedIn(false);
        }
        setCheckingStatus(false);
    }, [user]); // iniciará quando o usuário mudar
    return { loggedIn, checkingStatus };
};

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\pages\Home.jsx ======
import { Link } from 'react-router-dom';
import { FaQuestionCircle, FaTicketAlt } from 'react-icons/fa';

function Home() {
  return (
    <>
      <section className="heading">
        <h1>Bem-vindo, o que você precisa?</h1>
        <p>Escolha uma opção abaixo</p>
      </section>
      <Link to="/new-ticket" className="btn btn-reverse btn-block">
        <FaQuestionCircle />
        Crie um ticket novo
      </Link>
      <Link to="/tickets" className="btn btn-block">
        <FaTicketAlt />
        Acessar meus tickets
      </Link>
    </>
  );
}

export default Home;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\pages\Login.jsx ======
// página muito similar ao componente Register

import { useState, useEffect } from 'react';
import { FaSignInAlt } from 'react-icons/fa';
import { toast } from 'react-toastify';
import { useSelector, useDispatch } from 'react-redux';
import { login, reset } from '../features/auth/authSlice';
import { useNavigate } from 'react-router-dom';
import Spinner from '../components/Spinner';

function Login() {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
  });
  const { email, password } = formData;
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const { user, isLoading, isSuccess, message, isError } = useSelector(
    (state) => state.auth
  );
  useEffect(() => {
    if (isError) {
      toast.error(message);
    }
    if (isSuccess || user) {
      navigate('/');
    }
    dispatch(reset());
  }, [isError, isSuccess, user, message, navigate, dispatch]);
  const onChange = (e) => {
    setFormData((prevState) => ({
      ...prevState,
      [e.target.name]: e.target.value,
    }));
  };
  const onSubmit = (e) => {
    e.preventDefault();
    const userData = {
      // pega dados do formulário (local state)
      email,
      password,
    };
    dispatch(login(userData)); // permite enviar a função em authSlice. agora ambos formulários estão conectados (register e login)
  };
  if (isLoading) {
    return <Spinner />;
  }
  return (
    <>
      <section className="heading">
        <h1>
          <FaSignInAlt /> Acesso
        </h1>
        <p>Logue sua conta</p>
      </section>
      <section className="form">
        <form onSubmit={onSubmit}>
          <div className="form-group">
            <input
              type="email"
              className="form-control"
              id="email"
              name="email"
              value={email}
              onChange={onChange}
              placeholder="Digite seu e-mail"
              required
            />
          </div>
          <div className="form-group">
            <input
              type="password"
              className="form-control"
              id="password"
              name="password"
              value={password}
              onChange={onChange}
              placeholder="Digite sua senha"
              required
            />
          </div>
          <div className="form-group">
            <button className="btn btn-block">Enviar</button>
          </div>
        </form>
      </section>
    </>
  );
}

export default Login;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\pages\NewTicket.jsx ======
import { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { toast } from 'react-toastify';
import { createTicket, reset } from '../features/tickets/ticketSlice';
import Spinner from '../components/Spinner';
import BackButton from '../components/BackButton';

function NewTicket() {
  const { user } = useSelector((state) => state.auth); // antes de pegar e setar o state, será pego o user do global state
  const { isLoading, isError, isSuccess, message } = useSelector(
    (state) => state.tickets
  );
  const [name, setName] = useState(user.name);
  const [email, setEmail] = useState(user.email);
  const [product, setProduct] = useState('Suporte geral do Windows 10 ou 11');
  const [description, setDescription] = useState('');
  const dispatch = useDispatch();
  const navigate = useNavigate();
  useEffect(() => {
    if (isError) {
      toast.error(message);
    }
    if (isSuccess) {
      dispatch(reset());
      navigate('/');
    }
  }, [dispatch, isError, isSuccess, navigate, message]);
  const onSubmit = (e) => {
    // "ticketService" conectado com "ticketSlice" permite trazer "createTicket", e, com isso, enviar através do form
    e.preventDefault();
    dispatch(createTicket({ product, description }));
  };
  if (isLoading) {
    return <Spinner />;
  }
  return (
    <>
      <BackButton url="/" />
      <section className="heading"></section>
      <h1>Crie um novo ticket</h1>
      <p>Preencha os campos abaixo</p>
      <section className="form">
        <div className="form-group">
          <label htmlFor="name">Seu nome</label>
          <input type="text" className="form-control" value={name} disabled />
        </div>
        <div className="form-group">
          <label htmlFor="email">Seu e-mail</label>
          <input type="text" className="form-control" value={email} disabled />
        </div>
        <form onSubmit={onSubmit}>
          <div className="form-group">
            <label htmlFor="product">Categorias: </label>
            <select
              name="product"
              id="product"
              value={product}
              onChange={(e) => setProduct(e.target.value)}
            >
              <option value="Suporte geral do Windows 10 ou 11">
                Suporte geral do Windows 10 ou 11
              </option>
              <option value="Montagem e upgrade de desktop">
                Montagem e upgrade de desktop
              </option>
              <option value="Análise de telas azuis">
                Análise de telas azuis
              </option>
            </select>
          </div>
          <div className="form-group">
            <label htmlFor="description">Descrição do problema</label>
            <textarea
              name="description"
              id="description"
              className="form-control"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
            ></textarea>
          </div>
          <div className="form-group">
            <button className="btn btn-block">Enviar</button>
          </div>
        </form>
      </section>
    </>
  );
}

export default NewTicket;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\pages\Register.jsx ======
import { useState, useEffect } from 'react';
import { FaUser } from 'react-icons/fa';
import { toast } from 'react-toastify';
import { useSelector, useDispatch } from 'react-redux'; // hook "useSelector" permite seleções do global state. "useDispatch" permite enviar ações
import { register, reset } from '../features/auth/authSlice'; // reset é um reducer que redefine os valores dos states para o padrão
import { useNavigate } from 'react-router-dom';
import Spinner from '../components/Spinner';

function Register() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    password2: '', // senha de confirmação do formulário
  });
  const { name, email, password, password2 } = formData; // desestruturação
  const dispatch = useDispatch(); // irá despachar "register" e outras funções
  const navigate = useNavigate();
  const { user, isLoading, isError, isSuccess, message } = useSelector(
    // traz pedaços do global state em um componente através do hook "useSelector"
    (state) => state.auth
  );
  useEffect(() => {
    // traz todos pedaços de state
    if (isError) {
      toast.error(message); // "mesage" será definida no redux através do hook "useSelector"
    }
    if (isSuccess || user) {
      // se sucesso e "user" preenchido
      navigate('/'); // redireciona para página inicial
    }
    dispatch(reset()); // reseta para padrão
  }, [isError, isSuccess, user, message, navigate, dispatch]);
  const onChange = (e) => {
    // parâmetro evento
    setFormData((prevState) => ({
      // o nome recém-criado atualizará o valor de "name" em "formData" pelo valor escrito no form
      ...prevState, // todos os campos passados
      [e.target.name]: e.target.value,
    }));
  };
  const onSubmit = (e) => {
    e.preventDefault();
    if (password !== password2) {
      toast.error('Senha não coincide');
    } else {
      const userData = {
        name,
        email,
        password,
      };
      dispatch(register(userData)); // envia o register de "authSlice.js"
    }
  };
  if (isLoading) {
    return <Spinner />;
  }
  return (
    <>
      <section className="heading">
        <h1>
          <FaUser /> Cadastramento {/* {user} */}
        </h1>
        <p>Crie uma conta</p>
      </section>
      <section className="form">
        <form onSubmit={onSubmit}>
          <div className="form-group">
            <input
              type="text"
              className="form-control"
              id="name"
              name="name"
              value={name}
              onChange={onChange}
              placeholder="Digite seu nome"
              required
            />
          </div>
          <div className="form-group">
            <input
              type="email"
              className="form-control"
              id="email"
              name="email"
              value={email}
              onChange={onChange}
              placeholder="Digite seu e-mail"
              required
            />
          </div>
          <div className="form-group">
            <input
              type="password"
              className="form-control"
              id="password"
              name="password"
              value={password}
              onChange={onChange}
              placeholder="Digite sua senha"
              required
            />
          </div>
          <div className="form-group">
            <input
              type="password"
              className="form-control"
              id="password2"
              name="password2"
              value={password2}
              onChange={onChange}
              placeholder="Confirme sua senha"
              required
            />
          </div>
          <div className="form-group">
            <button className="btn btn-block">Enviar</button>
          </div>
        </form>
      </section>
    </>
  );
}

export default Register;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\pages\Ticket.jsx ======
import { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { getTicket, reset, closeTicket } from '../features/tickets/ticketSlice';
import BackButton from '../components/BackButton';
import Spinner from '../components/Spinner';
import NoteItem from '../components/NoteItem';
import { useParams, useNavigate } from 'react-router-dom';
import { toast } from 'react-toastify';
import {
  getNotes,
  createNote,
  reset as notesReset,
} from '../features/notes/noteSlice';
import Modal from 'react-modal';
import { FaPlus } from 'react-icons/fa';
import { FaTimes } from 'react-icons/fa';

const customStyles = {
  content: {
    width: '600px',
    top: '50%',
    left: '50%',
    right: 'auto',
    bottom: 'auto',
    marginRight: '-50%',
    transform: 'translate(-50%, -50%)',
    position: 'relative',
  },
};

Modal.setAppElement('#root'); // o app element é "root" porque virá do index html e será montado na raiz

function Ticket() {
  const [modalIsOpen, setModalIsOpen] = useState(false);
  const [noteText, setNoteText] = useState('');
  const { ticket, isLoading, isSuccess, isError, message } = useSelector(
    (state) => state.tickets
  );
  const { notes, isLoading: notesIsLoading } = useSelector(
    (state) => state.notes
  );
  const params = useParams();
  const navigate = useNavigate();
  const dispatch = useDispatch();
  const { ticketId } = useParams(); // pega o ticket da url
  useEffect(() => {
    if (isError) {
      toast.error(message);
    }
    dispatch(getTicket(ticketId));
    dispatch(getNotes(ticketId));
    // eslint-disable-next-line
  }, [isError, message, ticketId]);
  const onTicketClose = () => {
    // event handler de fechar um ticket
    dispatch(closeTicket(ticketId));
    toast.success('Ticket fechado');
    navigate('/tickets');
  };
  const onNoteSubmit = (e) => {
    e.preventDefault();
    // console.log('Enviado');
    dispatch(createNote({ noteText, ticketId }));
    closeModal();
  };
  const openModal = () => setModalIsOpen(true);
  const closeModal = () => setModalIsOpen(false);
  if (isLoading || notesIsLoading) {
    return <Spinner />;
  }
  if (isError) {
    return <h3>Algo deu errado</h3>;
  }
  return (
    <div className="ticket-page">
      <header className="ticket-header">
        <BackButton url="/tickets" />
        <h2 style={{ marginBottom: '0px' }}>
          ID do ticket
          <span className={`status status-${ticket.status}`}>
            {ticket.status}
          </span>
        </h2>
        <p style={{ marginTop: '0px' }}>{ticket._id}</p>
        <h3 style={{ marginBottom: '0px' }}>Data enviada</h3>
        <p style={{ marginTop: '0px' }}>
          {new Date(ticket.createdAt).toLocaleString('pt-br')}
        </p>
        <h3 style={{ marginBottom: '0px' }}>Categoria</h3>
        <p style={{ marginTop: '0px' }}>{ticket.product}</p>
        <hr />
        <div className="ticket-desc">
          <h3>Descrição do problema </h3>
          <textarea
            className="ticket-desc"
            value={ticket.description || ''} // Garante que não haja erro se ticket.description for undefined
            readOnly
            style={{
              resize: 'none',
              width: '100%',
              minHeight: '100px',
              height: 'auto',
              border: 'none',
              backgroundColor: 'transparent',
              fontFamily: 'inherit',
              fontSize: 'inherit',
              padding: '0',
            }}
          >
            {ticket.description}
          </textarea>
        </div>
      </header>
      {ticket.status !== 'fechado' && (
        <>
          <h2>Observações</h2>
          <button className="btn" onClick={openModal}>
            <FaPlus />
            Adicionar
          </button>
        </>
      )}
      <Modal
        isOpen={modalIsOpen}
        onRequestClose={closeModal}
        style={customStyles}
        contentLabel="Criar observação"
      >
        <h2>Haveria algo mais a ser descrito?</h2>
        <button className="btn-close" onClick={closeModal}>
          <FaTimes />
        </button>
        <form onSubmit={onNoteSubmit}>
          <div className="form-group">
            <textarea
              name="notetext"
              id="notetext"
              className="form-control"
              value={noteText}
              onChange={(e) => setNoteText(e.target.value)}
            ></textarea>
          </div>
          <div className="form-group">
            <button className="btn" type="submit">
              Enviar
            </button>
          </div>
        </form>
      </Modal>
      {ticket.status !== 'fechado' && (
        <>
          {notes.map((note) => (
            <NoteItem key={note._id} note={note} />
          ))}
        </>
      )}
      {ticket.status !== 'fechado' && (
        <button className="btn btn-block btn-danger" onClick={onTicketClose}>
          Encerrar ticket
        </button>
      )}
      {/* só exibe o botão caso o ticket não esteja fechado */}
    </div>
  );
}

export default Ticket;

====== C:\Users\Administrator\Desktop\suporte-tecnico\frontend\src\pages\Tickets.jsx ======
import { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { getTickets, reset } from '../features/tickets/ticketSlice';
import Spinner from '../components/Spinner';
import BackButton from '../components/BackButton';
import TicketItem from '../components/TicketItem';

function Tickets() {
  const { tickets, isLoading, isSuccess } = useSelector(
    (state) => state.tickets
  );
  const dispatch = useDispatch();
  useEffect(() => {
    // limpa o state ao desmontar e conserta bug de memory leak
    return () => {
      if (isSuccess) {
        dispatch(reset);
      }
    };
  }, [dispatch, isSuccess]);
  useEffect(() => {
    dispatch(getTickets());
  }, [dispatch]);
  if (isLoading) {
    return <Spinner />;
  }
  return (
    <>
      <BackButton url="/" />
      <h1>Tickets</h1>
      <div className="tickets">
        <div className="ticket-headings">
          <div>Data</div>
          <div>Categoria</div>
          <div>Situação</div>
          <div></div>
        </div>
        {tickets.map((ticket) => (
          <TicketItem key={ticket._id} ticket={ticket} />
        ))}
      </div>
    </>
  );
}

export default Tickets;

